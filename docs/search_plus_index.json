{"./":{"url":"./","title":"云原生 Spring 实战 （MEAP)","keywords":"","body":"云原生 Spring 实战 （MEAP) 《Cloud Native Spring in Action With Spring Boot and Kubernetes》 预计将于 2022 年春出版。现在的翻译基于 Manning 出版社的 MEAP 版本。 地址：https://www.manning.com/books/cloud-native-spring-in-action LiveBook: https://livebook.manning.com/book/cloud-native-spring-in-action 强烈推荐您购买此书 尊重作者，保护版权 GitHub地址：https://github.com/LeonLi0102/cloud-native-spring-in-action-translate.git "},"welcome.html":{"url":"welcome.html","title":"欢迎","keywords":"","body":"欢迎 感谢您购买 MEAP 版的《Cloud Native Spring In Action》。 为了从本书中获得最大的收益，您需要熟练掌握 Java 编程，需要具有构建 web 应用程序的经验，还要有 Spring 核心功能的基本知识。我假设您也熟悉 Git、面向对象编程、分布式系统、数据库和测试等。 在过去的几年中，越来越明显的是，许多组织不得不选择上云来保持经营活动。基于应用服务器和“雪花”（参考 SnowflakeServer）式内部传统基础架构，很难满足现代应用程序的需求：可扩展性、弹性、零停机时间、可靠性、短反馈周期和频繁发布。为了充分利用云的功能，只将传统应用程序迁移到新的基础架构是不够的，还需要一些别的东西。应用程序必须成为云原生应用程序。 本书将带领您在云原生世界中展开一段激动人心的旅程。从开发环境到生产环境，使用 Spring、Docker 和 Kubernetes 的最新功能。您将有机会实现每一个新想法，逐步为在线书店构建一个完整的云原生系统。到本书结束，您将把它部署到公有云的 Kubernetes 集群中。 本书分为四个部分。第 1 部分将引导您了解云原生环境，定义成为云原生应用程序需要些什么，并建立一些工具、技术和模式，以备后续使用。 第 2 部分将让您了解云原生开发的基础知识。您将了解 与 Spring RESTful 服务和数据持久化。了解如何跨环境管理配置，定义自动化持续集成过程，了解 Docker 容器化如何工作。最后将您的应用部署到本地 Kubernetes 集群。 在第 3 部分中，您的旅程将达到一个全新的高度。您将单体应用迁移到云上的分布式系统中。您将了解响应式编程、可扩展性、弹性和边缘服务。然后，您将探索事件驱动体系结构，并通过身份验证、授权和加密保护您的系统。 第 4 部分中，您将确保应用程序的可观测性，处理日志记录、跟踪和监视。最后，您将到达渴望已久的目的地：生产环境。您将学习如何将应用程序部署到 Kubernetes 公有云集群，并实现自动化交付和部署。在生产环境的新旅程开始了。您将熟悉云原生冒险中的下一步，学习迁移现有应用程序。 请让我知道您对目前为止所写的这些内容的想法，以及您希望在接下来的章节中看到哪些内容？欢迎您在 liveBook 讨论论坛 上发表意见 —— 您的反馈对改进《Cloud Native Spring In Action》一书有重要价值。 您可以在 GitHub 附带的存储库中找到本书中使用的所有代码示例。 再次感谢您的关注和购买！ —Thomas Vitale "},"01-Introduction-to-cloud-native/Introduction.html":{"url":"01-Introduction-to-cloud-native/Introduction.html","title":"第 1 章 云原生简介","keywords":"","body":"第 1 章 云原生简介 本章内容： 什么是云和云计算模型 云原生的定义 云原生应用的特性 支持云原生的文化和实践 您应该考虑云原生的时间点和原因 云原生应用程序的拓扑和体系结构 云原生应用是高度分布式的系统，它们运行在云中，对变化的适应能力很强。系统由多个服务组成，这些服务通过网络进行通信，并部署在动态环境中，其中所有内容都在不断变化。 在深入研究 Spring、Docker 和 Kubernetes 之前，最基本的是首先定义什么是云原生。像我们领域中的其他流行语（如敏捷、DevOps 或 微服务）一样，云原生有时会被误解，并且可能会引起混淆，因为它对不同的人意味着不同的事情。 在本章中，我将为您提供本书其余部分所需的概念。首先，我将定义云原生并说明一个应用成为云原生应用所需的条件。我将解释云原生应用程序的属性，考查云计算模型的特性，并讨论您应该何时以及为什么要迁移到云。我还将介绍一些云原生拓扑和体系结构的基本概念。图 1.1 显示了我将在本章中介绍的所有不同元素的概述，以定义和限定云原生系统。在本章的最后，您将开始使用 Spring 构建云原生应用程序并使用 Kubernetes 部署它们的旅程。 图 1.1 云原生是一种利用云技术的应用程序开发方法。本章涵盖六个主要领域来定义什么是云原生：云计算、应用程序属性、实践、拓扑、体系结构和目标。 "},"01-Introduction-to-cloud-native/1.1-What-is-cloud-native/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.1-What-is-cloud-native/Introduction.html","title":"1.1 什么是云原生","keywords":"","body":"1.1 什么是云原生 2010 年 5 月 25 日，云计算行业的老手 Paul Fremantle 在他的博客上写了一篇题为“Cloud Native”的文章。他是最早使用“Cloud Native”一词的人之一。在一个诸如微服务、Docker、DevOps、Kubernetes 或 Spring Boot 等概念和技术尚不存在的时期，Fremantle 与他的 WSO2 团队讨论了如何让“应用程序和中间件在云环境中良好工作”，也就是云原生。 Fremantle 解释的关键概念是，应用程序应专门为云设计，并具有利用其运行的新环境和云计算模型的特性。您可以将一个传统的应用程序（设计为在非云环境运行）移动到云上，这种方法通常被称为“lift and "},"01-Introduction-to-cloud-native/1.1-What-is-cloud-native/1.1.1-The-Three-Ps-of-Cloud-Native.html":{"url":"01-Introduction-to-cloud-native/1.1-What-is-cloud-native/1.1.1-The-Three-Ps-of-Cloud-Native.html","title":"1.1.1 什么是云原生","keywords":"","body":"1.1.1 什么是云原生 专门为云设计的应用程序到底意味着什么呢？云原生计算基金会（CNCF）在其云原生定义中回答了这个问题。 云原生技术使组织可以构建和运行可扩展的应用程序，这些应用运行在现代的、动态的环境中，如公有云、私有云和混合云。容器、服务网格、微服务、不变的基础设施和声明式 API 就是典型的示例。 这些技术使松散耦合的系统具有弹性、可管理性和可观测性。与强大的自动化相结合，它们允许工程师用最少的劳动，进行频繁的和可预测的重大功能更新。 根据这个定义，我确定了三组信息，我称之为云原生的 3 个 P： 位置（Place）。云原生应用程序的运行环境是现代的、动态的环境：云（公共云、私有云或混合云）。 特性（Properties）。云原生应用程序是可伸缩的、松耦合、有弹性、可管理、可观测的。 实施（Practices）。围绕云原生应用程序的实践包括健壮的自动化、结合频繁且可预测的更改：自动化、持续交付和 DevOPs。 什么是云原生计算基金会？ 云原生计算基金会（CNCF），是 Linux 基金会的一部分。致力于构建可持续的生态系统，促进社区支持云原生开源软件的增长和健康。CNCF 主办了许多云原生技术和项目，以支持云的可移植性，但并没有固定供应商。如果您想寻找云原生方面的项目，我建议查看 CNCF 云原生互动全景。 在以下部分中，我们将进一步研究这些概念。不过，首先，我希望您注意，云原生的定义是与任何特定的实现或细节无关的。CNCF 在定义中提到的这些，比如容器和微服务，都只是例子。最常见的误解是，在开始迁移到云时您必须采用微服务架构并构建容器。然而事实并非如此。Fremantle 在 2010 年的文章就是证明。他没有提到这些，因为当时这些技术都不存在。然而，他所描述的应用程序不仅仍然被认为是云原生的，而且还被认为是符合 CNCF 八年后给出的定义的。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/Introduction.html","title":"1.2 云和云计算模型","keywords":"","body":"1.2 云和云计算模型 在关注主要角色，即云原生应用程序之前，我想先介描述一下我们这个旅程发生的地点，也是云原生应用程序运行的环境：云。如下图所示，我将在本节中定义云及其主要特性。如图 1.2 所总结的，如果云原生应用程序设计为在云环境中良好运行，您应该要知道那是什么样的环境。 图 1.2 云是一种以不同计算模型为特性的 IT 基础设施，云供应商根据消费者需求的不同控制程度来提供服务。 云是一种根据云计算模型，支持向消费者交付计算资源的 IT 基础设施。国家标准与技术研究所（NIST）对云计算的定义如下： 云计算是一种模型，它支持对网络进行无处不在、方便的按需访问可配置计算资源的共享池（例如，网络、服务器、存储器、应用程序和服务等），可以用最少的管理工作与服务提供者交互。 就像你从供应商那里获得电力，而不是自己发电一样。通过云您可以获得作为商品的计算资源（例如，服务器、存储和网络）。 云提供商管理底层云基础设施，因此消费者无需担心机器或网络等物理资源。迁移到云的公司可以通过网络（通常是 Internet）获取计算资源。通常会使用一组 API 形成自助服务，根据需要按需调配和扩展资源。 弹性是该模型的主要特性之一：计算资源可以根据需求动态调配和发布。 弹性是指系统能够通过资源调配来适应工作负载变化的程度，以自主方式进行资源调配，以便在每个时间点，使可用资源与当前需求尽可能匹配。 传统 IT 基础设施无法提供弹性能力。公司必须计算所需的最大计算能力，并建立支持该能力的基础设施，即使大部分情况下只是偶尔需要。随着云计算模型的出现，计算资源受到监控，消费者只为他们实际使用的东西付费。 对于云基础设施应该在哪里或应该由谁提供，没有严格的要求。云服务有几种部署模型，主要是私有云、公共云和混合云。 私有云。为单个组织使用而配置的云基础架构。可以由组织本身或第三方管理，也可以内部部署或外部托管。对于要处理敏感数据或非常关键系统的组织，私有云通常是云计算的首选选项。这也是一个常见选择，完全控制基础设施以符合特定法律和法规，像《通用数据保护条例》（GDPR）或《加州消费者隐私法》（CCPA）。例如，银行和医疗服务提供商很可能建立自己的云基础设施。 公共云。为公共使用而配置的云基础架构。它通常是由某组织所有并提供管理，也就是云服务商，都托管在提供商的场所。公有云服务提供商的例子有 Amazon Web Services（AWS）、Microsoft Azure 和 Google Cloud。 混合云。由两个或多个不同的云基础架构组成，由前面的类型绑定在一起并提供服务，就好像它们是一个单一的环境。 云计算模型提供了五种主要的服务模型，具体取决于给消费者提供哪些功能。关于选择哪种服务模型的决策，应该是由消费者对基础设施的需求控制程度，以及他们需要管理的哪种类型的计算资源。图 1.3 显示了领先的云计算服务与传统基础设施的比较模型，并显示了维护每个基础设施级别的人员：消费者或云提供商。 图 1.3 云计算服务模型。它们的不同之处在于它们提供的抽象级别（例如，使用 IaaS，用户管理虚拟机）以及谁负责管理哪些虚拟机级别（例如，对于 CaaS，使用者管理容器，提供者管理底层容器基础设施）。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.1-Infrastructure-as-a-Service.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.1-Infrastructure-as-a-Service.html","title":"1.2.1 基础设施即服务","keywords":"","body":"1.2.1 基础设施即服务 在基础设施即服务（IaaS）模型中，消费者可以直接控制提供的资源，如服务器、存储和网络等。例如，他们可以配置虚拟机并安装操作系统和库等软件。这个模型已经被使用相当长的时间了，直到亚马逊在 2006 年因推出 Amazon Web Services 使其大受欢迎。IaaS 产品的例子有 Amazon Elastic Compute Cloud（EC2），Microsoft Azure Virtual Machines 和 Google Compute Engine。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.2-Container-as-a-Service.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.2-Container-as-a-Service.html","title":"1.2.2 容器即服务","keywords":"","body":"1.2.2 容器即服务 使用容器即服务（CaaS）模型，使用者不能控制原始虚拟化资源。相反，他们管理的是容器。云服务商将提供满足这些容器所需的底层资源。例如，启动新的虚拟机并配置网络以使其可通过互联网访问。Docker Swarm 和 Kubernetes 提供的是 CaaS 级别的服务。所有主要云服务商都提供托管 Kubernetes 服务，这已成为事实上的 CaaS 标准：Amazon Elastic Kubernetes Service（EKS）、Microsoft Azure Kubernetes Service（AKS）和 Google Kubernetes Engine（GKE）。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.3-Platform-as-a-Service.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.3-Platform-as-a-Service.html","title":"1.2.3 平台即服务","keywords":"","body":"1.2.3 平台即服务 在平台即服务（PaaS）模型中，云服务商管理栈直至运行时和容器级别。消费者运行和管理应用程序，而平台处理其余所有事情。例如，作为开发人员，您可以构建 Java 应用程序，将其打包为 JAR 文件，然后将其部署到根据 PaaS 模型工作的平台。平台提供 Java 运行时和其他必需的中间件，还可以提供其他服务，如数据库或消息传递系统。PaaS 产品的例子有 Cloud Foundry、Heroku 和 AWS Elastic Beanstalk 和 Google App Engine。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.4-Function-as-a-Service.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.4-Function-as-a-Service.html","title":"1.2.4 功能即服务","keywords":"","body":"1.2.4 功能即服务 功能即服务（FaaS）模型利用无服务器计算让消费者管理由事件触发的功能。云提供处理所有其余事情。在这个模型中，开发人员构建单个功能，而不是整个应用程序。FaaS 平台配置何时应执行此类功能。例如，您可以编写一个函数，该函数在消息队列可用时分析数据集并计算结果。FaaS 产品的例子有 Amazon AWS Lambda、Microsoft Azure Functions 和 Google Cloud Functions。 "},"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.5-Software-as-a-Service.html":{"url":"01-Introduction-to-cloud-native/1.2-The-cloud-and-the-cloud-computing-model/1.2.5-Software-as-a-Service.html","title":"1.2.5 软件即服务","keywords":"","body":"1.2.5 软件即服务 抽象程度最高的服务是软件即服务（SaaS）。在这个模型中，消费者只能作为用户访问应用程序，而云服务商管理整个应用程序堆栈。许多公司构建应用程序，使用 CaaS 或 PaaS 模型运行它们，然后将其作为 SaaS 销售给终端客户。SaaS 应用程序的消费者通常使用 瘦客户端 web 浏览器来访问它们。作为 SaaS 提供的应用程序示例如下 Salesforce、ProtonMail 和 Microsoft Office 365。 Platform 还是 PaaS 服务 平台（Platform）这个术语可能会在云计算中产生一些混乱。让我们讨论澄清一下。通常，平台是一个操作环境，用于运行和管理应用程序。所以，Google Kubernetes Engine（GKE）是一个根据 CaaS 模型提供云服务的平台。Microsoft Azure Functions 是一个提供以 FaaS 为模型服务的平台。在较低的级别上，如果您将应用程序直接部署在 Ubuntu 机器上，那台机器就是您的平台。在书的其余部分，每当我使用平台（Platform）这个术语时，除非单独说明，我指的是刚才解释的这个更广泛的概念。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/Introduction.html","title":"1.3 云原生应用的特性","keywords":"","body":"1.3 云原生应用的特性 场景已经设置好了：在云中。您应该如何设计应用程序以充分利用它的特点呢？CNCF 确定了云原生应用程序应该有的五个主要特性。就其本身而言，其想法是云原生是一种构建和运行应用程序，以展示出这些特性的方法论。Cornelia Davis 总结道，“云原生软件是由您的计算方式，而不是由在什么地方计算来决定的”。换句话说，云表示的是何处，云原生表示是怎么实现。 前面已经讲述了表示何处的部分：云。现在，让我们继续探索如何进行实现。做为一个快速参考，图 1.4 列出了相关特性和简短说明。 图 1.4 云原生应用程序的主要属性是可伸缩性、松耦合、弹性、可管理性和可观察性。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.1-Scalability.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.1-Scalability.html","title":"1.3.1 可扩展性","keywords":"","body":"1.3.1 扩展性 云原生应用程序是可扩展的，这意味着如果需要，它可以为不断增加的工作负载提供额外的资源。根据这些额外资源的性质，可分为垂直扩展和水平扩展。 垂直扩展。垂直缩放或上下缩放，这意味着给计算节点添加或删除硬件资源，如 CPU 或 内存。这种方法是有限度的，因为不可能无限添加硬件资源。另一方面，应用程序不需要做什么特殊设计就可以缩放。 水平扩展。水平缩放或内外缩放，意味着添加更多计算节点或容器（例如，当使用 Kubernetes 时）到系统中。这种方法与垂直扩展不同，几乎没有限制，但它需要应用程序要特别处理以支持水平扩展。 传统系统通常会在工作负载增加的情况下采用垂直扩展。添加 CPU 和内存是应用程序支持更多用户，而无需（重新）设计以实现扩展的常用方法。在特定情况下，这仍然是一个不错的选择，但是云需要其他东西。 在云中，一切都是动态不断变化的，水平扩展是首选。基于云计算模型提供的抽象级别，可以直接启动应用程序的新实例，而不是增加已经运行的机器的计算能力。因为云是有弹性的，所以可以在短时间内动态地进行缩放。我把弹性作为一个主要特性来讨论：根据需求主动采取行动，调配和释放计算资源。可伸缩性是弹性的先决条件。 图 1.5 显示了垂直扩展和水平扩展之间的区别。在垂直扩展情况下，我们通过向现有虚拟机添加更多资源来扩展。在水平扩展情况下，我们添加另一个虚拟机，以帮助现有虚拟机处理额外的工作负载。 图1.5 当您需要支持不断增加的工作负载时，垂直扩展模型将添加硬件资源给计算节点，而水平扩展模型将增加更多计算节点。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.2-Loose-coupling.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.2-Loose-coupling.html","title":"1.3.2 松耦合","keywords":"","body":"1.3.2 松耦合 松耦合是系统的一个基本特性，即系统各部分之间尽可能少的相互依赖。其目标是可以独立地开发每一个部分，以便于某部分的修改，不影响其他部分。 几十年来，耦合 及其孪生概念 内聚 在面向对象的软件工程中起着至关重要的作用。将系统分解为模块（模块化），最小化对其他部分依赖（松耦合），并对代码的修改封闭（高内聚），是一种很好的设计实践。。根据架构风格的不同，可以对整体或对独立服务（例如，微服务）进行建模。不管怎样，您都应该瞄准目标，按松散耦合和高内聚性进行模块化。 Parnas 指出了模块化的三个好处： 可管理性。由于每个模块都是松散耦合的，因此团队应该可以减少开发的时间，因为与其他团队进行大量协调和沟通就不需要了。 产品灵活性。每个模块应独立于其他模块进行演变，形成了一个非常灵活的系统。 可理解性。不必从整体上研究系统来理解一个特定的模块，而是一次一个模块的研究。 上述好处通常都是与微服务相关的好处。事实上您不需要用微服务来实现它们。在过去几年中，许多组织决定从单体服务迁移到微服务。他们中的一些人因为缺乏适当的模块化经验而失败了。一个单体应用，由紧密耦合的组件组成整体，迁移后会产生一个紧密耦合、无内聚性的微服务系统。有时称为分布式单体。如果您告诉我，这不是一个好名字，因为按定义来说它意味着，这是由紧密耦合的非内聚组件组成的。这不全对。是何种架构都无关紧要：糟糕的设计就是糟糕的设计。事实上，我喜欢 Simon Brown 提出的模块化单体术语，旨在提高人们的认识，就是单体应用也可以优化成松散耦合和高内聚，最终单体和微服务都混在了一起，成为“大泥球”。 在本书中，我将介绍一些应用程序中实施松耦合的技术。特别是我将采用基于服务的体系结构，重点关注服务构建。服务力求高内聚，与其他服务的依赖要最小，服务之间使用清晰的接口相互通信。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.3-Resilience.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.3-Resilience.html","title":"1.3.3 强适应性","keywords":"","body":"1.3.3 韧性 如果系统即使在出现故障或环境发生变化的情况下也能提供服务，则系统是有韧性的。韧性是“面对故障或挑战性操作，软硬件网络仍能提供和维持一个可接受的服务水平”。 云原生应用程序在动态环境中运行，其中所有内容都在不断变化，并且故障可能随时会发生。这是无法阻止的。过去，我们习惯于把变化和故障作为异常。但对于高度分布式的系统，如云原生系统，变化不是异常：它们是常态。 您的目标应该是：无论基础架构或软件中是否出现故障，都要确保您的应用程序可用。 在讨论韧性时，有必要定义三个基本概念：故障、错误和失效。 故障（Fault）。是软件或基础设施中会产生错误内部状态的缺陷。示例：方法调用返回空值，即使其规范要求返回非 null 值。 错误（Error）。是指系统的预期行为与实际行为的差异。示例：由于上面的错误，将引发抛出 NullPointerException。 失效（Failure）。当触发故障并导致错误时，可能会发生失效，导致系统没有响应，无法按照其规范运行。示例：如果未捕获 NullPointerException，则错误会引发失效，系统将对任何请求返回 500 响应。 故障可能会变成错误，这可能会引发失效，因此您应该将应用程序设计为能够 容错（fault tolerant）。韧性的一个重要部分是确保失效不会波及到其他系统组件，而是使它保持隔离。您还需要这个系统能够 自我修复（self-repairing），而云模型实际上可以实现这一点。 在本书中，我将向您展示一些容错技巧，防止故障传播到系统的其他部分。例如，您将利用 Spring Cloud Circuit Breaker 和 Resilience4J 来实现断路器、重试和冗余。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.4-Observability.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.4-Observability.html","title":"1.3.4 可观测性","keywords":"","body":"1.3.4 可观测性 可观测性是来自控制理论的一个特性。考察一个系统时，可观察性是一种通过衡量外部输出，来推断其内部状态的方法。在软件工程中，系统是一个单一的应用程序或一个分布式系统。整体外部输出可以是度量、日志和跟踪等数据。图 1.6 显示了可观测性是如何工作的。 图 1.6 可观测性指的是通过外部输出推断应用程序的内部状态。可管理性是指通过外部输入来改变内部状态和输出。在这两种情况下，应用程序本身不会更改。它是不可变的。 Twitter 的可观测性工程团队确定了可观测性的四大支柱： 监测。监视是关于测量应用程序的某些特定方面，以获得有关其整体健康状况的信息并识别故障。在本书中，您将利用 Spring Boot Actuator 的监控功能，并将 Prometheus 与 Spring 集成来导出有关应用程序的相关度量信息。 警报/可视化。收集有关系统状态的数据只有在使用时才有用。在监测到应用程序发现故障时，应触发警报，并且应该采取一些措施来处理它。定制监控大盘用于可视化收集的数据，并将其绘制在相关图表中，旨在提供系统运行的良好视图。在本书中，您将了解如何使用 Grafana 可视化从云原生应用程序收集的数据。 分布式系统跟踪基础设施。在分布式系统中，仅仅跟踪每个子系统的行为是不够的。跟踪数据流经的不同子系统非常重要。在本书中，您将使用 Spring Cloud Sleuth 进行分布式链路跟踪，并整合 Spring 与 Jaeger，以对跟踪数据进行可视化。 日志聚合/分析。跟踪应用程序中的主要事件至关重要，可以推断软件的行为并在出现问题时进行调试。在云原生系统中，应聚合和收集日志，以便更好地了解系统行为，才有可能进行分析，从数据中挖掘信息。在本书中，我将较多地讨论日志。您将学习使用 EFK 技术栈（Elastic、Fluentd、Kibana）来收集和可视化日志。 "},"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.5-Manageability.html":{"url":"01-Introduction-to-cloud-native/1.3-Properties-of-cloud-native-applications/1.3.5-Manageability.html","title":"1.3.5 可管理性","keywords":"","body":"1.3.5 可管理性 在控制理论中，可观测性的对偶概念是可控性。可管理性代表了外部输入改变系统状态或有限时间间隔内输出的能力。这个概念引出云原生的最后一个主要特性：可管理性。 再次借鉴控制理论，我们可以说可管理性是一种衡量外部输入改变系统状态或系统输出有多容易的方法。更直白一点来说，它是一种无需更改代码即可修改应用程序行为的能力。不要与可维护性相混淆，可维护性是一个衡量从内部高效地更改系统，也就是说通过更改其代码有多容易的指标。图形 1.6 展示了可管理性是如何工作的。 可管理性的一个方面是部署和更新应用程序，同时保持整个系统是启用的、持续运行的。另一个因素是配置，整本中将深入讨论它。您希望使云原生应用程序可配置，以便在不更改代码和构建新版本的情况下修改其行为。进行配置修改很常见，如修改数据源 URL、服务凭据和证书。比如，根据环境的不同，您可以使用不同的数据源：一个用于开发，一个用于测试，一个用于生产。还可以使用其他类型的配置，用于决定是否应在运行时启用特定功能的标志。 可管理性不仅关系到变更本身，还关系到您应用这一修改是否轻松、高效。云原生系统非常复杂，因此设计应用程序可以适应功能、环境和安全方面不断变化的需求非常重要。考虑到复杂性，您应该致力于尽可能多地通过自动化进行管理，这让我们进入云原生的三个 P 中的最后一个：实践（Practices）。 "},"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/Introduction.html","title":"1.4 支持云原生的文化和实践","keywords":"","body":"1.4 支持云原生的文化和实践 在本节中，我将重点介绍 CNCF 给出的云原生定义的最后一句话：“与强大的自动化相结合，它们允许工程师用最少的劳动，进行频繁的和可预测的重大功能更新。” 我将讨论三个概念：自动化、持续交付和 DevOps，如图1.7 所示。 图 1.7 云原生开发的文化和实践。 "},"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.1-Automation.html":{"url":"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.1-Automation.html","title":"1.4.1 自动化","keywords":"","body":"1.4.1 自动化 自动化是云原生的核心原则。其思想是将重复的手动任务自动化，以加快云原生应用程序的交付和部署。可以自动化执行许多不同的任务，从构建应用程序到部署应用程序，从基础架构资源调配到配置管理。自动化最重要的优点是它使流程和任务可重复，整体系统更稳定可靠。手动执行一项任务容易出错，而且成本较高。通过使其自动化，您可以更可靠和更高效地得到结果。 云计算模型的特点是，提供的计算资源都在自动化的自助服务模式中，并具有弹性地增加或减少计算资源的能力。云基础设施的两大自动化类别：资源调配和配置管理。我们把它们称为: 架构即代码（infrastructure as code） 和 配置即代码（configuration as code）。 Martin Fowler 将 架构即代码 定义为：“像任何软件系统的代码一样，通过源代码定义计算和网络基础设施的方法”。 云服务商提供方便的 API 来创建和配置服务器、网络和存储。通过使用 Terraform 之类的工具自动化这些任务，将代码置于源代码控制中，使用与应用程序开发相同的测试和交付实践，您可以获得更多可靠的基础设施，可再生、更高效、风险更低。一个简单的例子：一个自动化的任务可能是创建一个新的虚拟机，它有 8 个 CPU，64GB 内存和 Ubuntu 20.04 LTS 操作系统。 配置计算资源后，您可以管理它们并自动配置它们。套用前面的定义，配置即代码 是像任何软件系统的代码那样，通过代码定义配置资源。 使用 Ansible 等工具，您可以用声明的方式编写服务器或网络的配置。例如，在上面设置 Ubuntu 服务器之后，您可以自动完成安装 Java 运行时环境（JRE）16.0.1、Python 3.7、在防火墙打开端口 8080 和 8443。这也适用于应用程序的配置。 通过自动化所有任务，来处理与基础架构资源调配和配置管理相关的工作，您可以避免不稳定、不可靠的 雪花服务器（snowflake server）（每一片雪花都是独一无二的，参考 SnowflakeServer ）。如果手动配置、管理每个服务器，结果将是一个独一无二的 雪花：一个脆弱的、独特的服务器，无法复制，任何更改都有风险。自动化有助于避免这种情况，有利于生成 凤凰服务器（phoenix servers）（凤凰涅槃，浴火重生，参考 PhoenixServer）：在这些服务器上执行的所有任务都是自动化的，每个更改都可以在源服务器中跟踪控制、降低风险，并且每个设置都是可复制的。将这一概念发挥到极致，实现所谓的 不可变服务器（参考 ImmutableServer），CNCF 在其云原生中也提到了这一点，来定义不可变的基础设施。 初始资源调配和配置后，不可变服务器 不再更改：它们是不变的。如果需要任何更改，则修改其定代码并提交。一个新的服务器最终根据新代码进行设置和配置，而上一个服务器被销毁。 在下一节中，我将讨论构建和部署应用程序的自动化。 "},"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.2-Continuous-delivery.html":{"url":"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.2-Continuous-delivery.html","title":"1.4.2 持续交付","keywords":"","body":"1.4.2 持续交付 CNCF 指出，云原生技术应与强大的自动化相结合，以经常进行影响较大的更改。其中一部分是通过持续交付提供的。 持续交付是“一种软件开发规程，让您在的软件可以随时投入生产的方式”。 通过持续交付，团队在短周期内实现功能，确保软件可在任何时间可靠释放。 持续集成（CI）是持续交付的先决条件，包括集成提交更改后的软件，构建它，并最终在类生产环境进行自动化测试。此过程应自动化，并由 CI 服务器执行。这个流程中涉及的步骤被声明为 流水线（pipelines）。 持续交付（CD）通过在流水线中包含额外步骤而构建在 CI 之上。之后通过运行自动化测试，软件被打包，发布版本被构建并部署到 类生产环境，以验证其是否有效。自动化流水在连续生产中的应用交付称为 部署流水线。 由于持续交付的基础是持续集成，我们通常将其称为 CI/CD。在本书中，您将构建部署流水线以保持发布分支处于良好状态。最后，您将使用它将应用程序自动部署到 Kubernetes 集群进行测试，然后发布到生产。 有时，人们会把 持续交付 与 持续部署 相混淆。前一种方法确保每次更改后，软件都处于可以部署的状态。何时真正做到这一点是一个业务决策。而对于连续部署，您可以在一个 CI/CD 流水线的最后添加一步，在每次发布后自动在生产中部署新版本。 持续交付 不仅仅是工具。这是一个规程，涉及文化和组织中的结构变化。设置自动化流水线以测试和交付您的应用程序，并不意味着您在进行持续交付。这就引出了下一个话题，也通常被误认为只是工具。 "},"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.3-DevOps.html":{"url":"01-Introduction-to-cloud-native/1.4-Culture-and-practices-supporting-cloud-native/1.4.3-DevOps.html","title":"1.4.3 DevOps","keywords":"","body":"1.4.3 DevOps DevOps 是另一个流行语，但有时也被误解了。当转向云原生时，这是一个需要掌握的重要概念。 DevOps 的起源很奇特。如果您有兴趣，我建议您在 YouTube 上看看 Ken Mugrage 的演讲。其中一个令人好奇的方面是，这部电影的创作者决定不提供这个概念的定义。结果是不同的人有不同的理解，我们最终使用 DevOps 表示了很多不同的东西。 在 DevOps 的所有定义中，我找到了 Ken Mugrage 提出的定义。他强调了 DevOps 的真正含义，其中包含大量信息也很有趣。 一种文化，在这种文化中，人们不分头衔或背景，共同规划、开发、部署和运维一个系统。 因此，DevOps 是一种文化，它是关于为了一个共同的目标而共同努力的。开发人员、测试人员、运维人员/运维工程师和其他人员，无论其职称或背景如何，都会参与，一起把想法带到生产中。 这意味着各自为战的终结，功能团队、QA 团队和运维团队之间不再有隔阂。DevOps 通常被认为是敏捷的自然延续，这也是小团队经常使用的概念，来向客户提供价值。亚马逊首席技术官 Werner Vogels 在 2006 年的一句著名的话，更简洁的描述了 DevOps，那时 DevOps 还未成型：“您建立它，您运行它”。 在定义了什么是 DevOps 之后，让我们简要介绍一下它不是什么。 DevOps 并不意味着没有运维。一个常见的错误是认为开发人员负责运维，这里运维人员的角色消失了。这是一种合作。一个团队包括这两种角色，有助于提高团队的整体技能，将创意变成产品。 DevOps 不是一个工具。像 Docker、Ansible、Splunk 和 Prometheus 这样的工具通常是称为 DevOps 工具，但这是错误的。DevOps 是一种文化。您不会因为使用这些工具而成为 DevOps 组织。换句话说，DevOps 不是产品，而是相关促成者的工具。 DevOps 不是自动化。即使自动化是 DevOps 的重要组成部分，但不是 DevOps 的定义。DevOps 是关于开发者和运维人员从构思到实践的合作，同时可能自动化一些流程，如 持续交付。 DevOps 不是一个角色。如果我们认为 DevOps 是一种文化，一种观念，很难理解 DevOps 角色。然而，对 DevOps 工程师的要求越来越高。通常，当招聘人员寻找 DevOps 工程师时，他们需要的技能包括熟练使用自动化工具、脚本和 IT 系统。 DevOps 不是一个团队。没有充分了解上述风险的组织，最终会保持与以前相同的思路。只不过是这样变化：添加一个 DevOps 筒仓（silo, 参考 Analysing the DevOps Silo）替换 Ops 筒仓或什么别的筒仓。 开发人员和运维人员之间的协作，在云原生中至关重要。您可能已经注意到，设计和构建云原生应用程序，需要您始终记住您将在哪里部署这些应用程序：云端。与运维人员合作允许开发人员设计和制造更高质量的产品。它叫 DevOps。但是让我们记住，这个定义不仅仅适用于开发人员和运维人员。相反，它泛指各类人，不分头衔或背景。这意味着合作也在其他角色之间进行，如测试人员和安全专家。他们共同负责整个产品生命周期的工作。有了 DevOps 思维，您可以真正实现 CNCF 定义的云原生应用目标：“允许工程师用最少的劳动，进行频繁的和可预测的重大功能更新”。 "},"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/Introduction.html","title":"1.5 上云是最好的选择吗？","keywords":"","body":"1.5 上云是最好的选择吗？ 我们行业中最大的错误之一，就是仅仅因为技术或方法是新的、每个人都在谈论它，就决定采用它。将的巨大的单体应用移植成微服务，最终导致灾难性失败的故事层出不穷。我已经解释了云和云原生应用程序的特性，这些应该能给您提供一些指引。如果您的系统不需要这些特性，也没有这些需要解决的相关问题，很可能“上云”对您的项目来说，并不是一个好的选择。 作为技术专家，很容易被最新、最时尚、最闪亮的技术所吸引。重点就是要弄清楚一种特定的技术或方法是否能解决您的问题。我们将想法变成软件，交付给客户，并为他们提供一些价值，这是我们的最终目标。如果某项技术或方法，能帮助您为客户提供更多价值，那么您应该考虑一下。如果它不会给客户带来更多价值，而您决定仍要这样做，您很可能会发现成本高、问题多，最后以失败告终。 什么时候上云？为什么公司都开始走上云这条路？走这条路最主要的目标如图 1.8 所示，云原生的主要目标是速度、规模、韧性、灵活性和成本。如果您的业务愿景包括这些目标，并且必须面对这些云技术试图解决的问题，那么考虑迁移到云，采用云原生方法是很好的。否则，最好仍保持现状。例如，如果您的公司在维护某个单体应用程序，而该服务不会再进一步扩展，而且在过去的几十年里一直运行良好，这就没有很好的理由将其迁移到云端，更不用说将其转变为一个新的应用程序以成为云原生应用了。 图 1.8 “云原生”的目标是实现速度、韧性、规模和成本优化。 "},"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.1-Speed.html":{"url":"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.1-Speed.html","title":"1.5.1 速度","keywords":"","body":"1.5.1 速度 能够更快地交付软件是当今企业的一个基本目标。将想法投入生产越快越好，较缩的上市时间是关键的竞争优势。能否在正确的时间，将正确的想法投入生产，就是成功和失败的差别。 客户希望实现越来越多的功能或修复 bug，他们希望立刻完成。他们不会乐意为我们的下一个软件版本等待六个月。他们的期望值不断增加，您需要一种方法来跟上这个节奏。一切都是为了给客户提供价值，并确保他们对结果感到满意。否则，您的公司将无法在激烈的竞争中生存。 更快、更频繁地交付不仅关系到竞争，还关系到客户给定的最后期限，也和缩短反馈周期有关。频繁和小规模的发布，意味着您可以尽快得到客户的反馈。较短的反馈周期，会让您发布的新功能有较低的风险。不是要花几个月的时间实现完美的功能，您可以很快将其发布，从客户那里获得反馈，然后调整它以符合客户的期望。此外，较小的版本包含较少的更改，因此更能减少可能出现故障的数量。 灵活性也是必需的，因为客户希望您的软件能够不断发展。例如，它应该足够灵活以支持新类型的客户端。如今，我们日常生活中的物品，越来越多的连接到互联网。想想各种各样的手机和物联网系统。您希望对任何未来的扩展和终端类型保持开放，以新的方式提供服务。 传统的软件开发方法都无法实现这些目标，它们总是重大发布、灵活性小和过长的发布周期。云原生方法，结合自动化任务、持续交付流水线和 DevOps 实践，有助于加快业务发展并缩短上市时间。 "},"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.2-Resilience.html":{"url":"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.2-Resilience.html","title":"1.5.2 韧性","keywords":"","body":"1.5.2 韧性 一切都在变化，失效总是在发生。我们试图预测失效，并将其视为异常的时代已经一去不复返了。正如我前面提到的，变化也不是异常。这是常规。 无论基础设施或软件是否出现故障，您的目标都是确保系统的可用性和可靠性。您希望继续为您的用户提供服务，即使是在降级模式下运行。 客户希望软件全天候可用，并在出现新功能后立即升级。停机或故障可能导致直接的金钱损失和客户不满。甚至会影响一个人的声誉，导致组织本身在未来市场上的机会受到损害。 即使发生错误，有韧性的系统仍能继续提供服务。要保证可用性，您需要在故障出现时采取适当措施来应对故障，处理它们，并确保整个系统仍能向用户提供服务。任何处理故障和升级等任务所需的操作都只不需要停机。客户期望如此。 没有任何硬件或软件是百分百可靠和可用的，因此您需要韧性。云原生应用程序利用底层云基础设施，设计为在面对变化时具有韧性。如果保持始终可用、安全和有韧性是您的需求，那么云原生对您来说是一个很好的选择。软件的韧性系统，反过来，可以提高速度：越稳定的系统，您可以更频繁地、更安全地发布新功能。 "},"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.3-Scale.html":{"url":"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.3-Scale.html","title":"1.5.3 规模","keywords":"","body":"1.5.3 规模 弹性是指能够根据负载进行扩展。您可以缩放一个弹性系统，确保为所有客户提供适当的服务级别。负载比平时要大时，您需要启动更多的服务实例来支持额外的负载。当发生了一些极端可怕的状况时，服务失败了，您需要能够启动新实例替换它们。 问题是，预测未来会发生什么是困难的。构建可伸缩的应用程序还不够。您需要它们能够动态缩放。每当有高负载时，您的系统应该动态、快速、轻松地扩展。随着时间的推移，当高峰来临时它应该会再次扩大。 如果您的业务需要快速、高效地适应新客户，或者需要灵活性来支持新类型的客户端（这会增加服务器上的工作负载），那么云的本质可以为您提供所需的所有弹性，与云原生相结合的应用程序可以按配置进行扩展。 "},"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.4-Cost.html":{"url":"01-Introduction-to-cloud-native/1.5-Is-the-cloud-your-best-option/1.5.4-Cost.html","title":"1.5.4 成本","keywords":"","body":"1.5.4 成本 作为一名软件开发人员，您可能不会直接与金钱打交道，但设计解决方案时考虑成本，也您的责任。凭借弹性和按需支付的策略，云计算模型有助于优化 IT 基础设施成本。不再总是开着基础设施，而是在需要时提供资源，支付实际使用费用，然后当您不再需要它们时，销毁它们。 最重要的是，采用云原生方法将导致进一步的成本优化。云原生应用程序被设计为是可伸缩的，以便它们可以利用云的弹性，因此与生产中的宕机和硬件故障相关的成本会降低。由于松散耦合，这能使团队效率提高，能有更快地上市时间，显著提高竞争优势。还有很多其他好处不再赘述。 上云的隐藏成本 在决定迁移到云之前，必须考虑其他的成本。一方面，您可以按如上所述优化成本。另一方面，您应该考虑迁移的成本和它的后果。迁移到云需要具备特定能力，但员工可能还不具有。这意味着要投资进行培训，或许还需要雇佣专业人士协助迁移到云。取决于所选的解决方案，还可能需要承担一些额外的责任，这反过来要求要有特定技能（例如，处理云安全问题）。还有其他需要考虑的因素，如迁移期间的业务中断、重新培训终端用户、更新文档和支持材料等等。 "},"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/Introduction.html","title":"1.6 云原生拓扑","keywords":"","body":"1.6 云原生拓扑 我对云原生的解释没有涉及具体的技术或架构。CNCF 在定义中提到了一些，比如容器和微服务。但正如我之前强调的，这些只是示例。创建云原生应用程序并不强制要求您使用 Docker 容器。考虑无服务器模型或 PaaS 解决方案，为 AWS Lambda 编写函数或将应用程序部署到 Heroku 都不需要构建容器，但这些都被归类为云原生。 在本节中，我将描述一些常见的云原生拓扑。首先，我将介绍容器和编排的概念，后续讨论 Docker 和 Kubernetes 时将进一步探讨这些概念。然后，我将介绍无服务器技术和函数的主题（FaaS）。在本书中，我不重点介绍 FaaS 模型，但我将介绍如何使用 Spring Native 和 Spring Cloud Function 构建无服务器应用程序。 图 1.9 突出显示了我将在本节中介绍的概念。 图 1.9 主要的云原生计算模型是容器（由编排器管理）和无服务器模型。 "},"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.1-Containers.html":{"url":"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.1-Containers.html","title":"1.6.1 容器","keywords":"","body":"1.6.1 容器 想象一下，您加入了一个团队，开始开发一个应用程序。您要做的第一件事就是遵循开发指南，将自己的开发环境设置成与同事类似的环境。您开发一个新特性，然后在质量测试（QA）环境中测试它。一旦验证通过，应用程序就可以准备部署，再经过一些额外的测试，就可以上生产。该应用程序是为在特定的环境中运行而构建的，因此必须使所有涉及的环境尽可能相似。您要怎么保证这一点呢？这就是容器的价值所在。 在使用容器之前，您将依赖虚拟机来保证环境的可复制性、隔离和可配置性。虚拟化通过利用虚拟机监控程序进行硬件抽象，使其能够在同一台物理机上运行多个操作系统，以一种相互隔离的方式。虚拟机监控程序将直接在机器硬件上运行（类型 1 ）或主机操作系统上运行（类型 2 ）。 另一方面，OS 容器是一个轻量级的可执行包，包含所有需要在内部运行应用程序的内容。容器共享同一内核：无需完全引导操作系统来添加新的隔离上下文。在 Linux 上，这可以利用 Linux 内核提供的功能。包括： 名称空间（namespaces） 用于在进程之间划分资源，以便每个进程（或进程组）只能看到机器上可用资源的子集； 控制组（cgroups） 用于控制和限制进程（或进程组）的资源使用。 仅使用虚拟化时，硬件是共享的，而容器也共享相同的操作系统内核。无论如何，两者都提供了用于隔离运行软件的计算环境，即使隔离的程度是不一样的。 图 1.10 显示了虚拟化和容器技术之间的区别。 图 1.10 虚拟化和容器技术在隔离上下文中共享的内容不同。虚拟机只共享硬件。容器也共享操作系统内核。后者更轻、更便携。 为什么容器在云原生应用中如此流行？传统上，您必须在虚拟机上安装并维护 JRE 和中间件，以使应用程序运行起来。而容器可以在几乎任何计算环境中可靠运行，独立于应用程序、其依赖项或中间件。不管是哪种应用程序，用哪种语言编写，或使用哪种库。从外部看，所有容器都有一个相似的形状，就像用于运输的集装箱一样。 因此，容器实现了灵活性、跨不同环境的可移植性和可重复部署性。由于轻量，对资源的要求较低，它们非常适合在云中运行，因为实例都是一次性的，会经常快速地扩缩。相比之下，构建和销毁虚拟机要昂贵得多，而且费时。 容器！到处都是容器！ 容器（Container） 是一个可以表示不同事物的词，这取决于文本的上下文。有时候模棱两可会产生一些混乱，所以让我们看看它在不同的语境中意味着什么。 操作系统。操作系统容器是一个与系统其余部分隔离的环境，是在系统中运行一个或多个进程的方法。在本书中，我们将重点介绍 Linux 容器，但请注意 Windows 容器也存在。 Docker。Docker 容器是 Linux 容器的实现，开放容器计划（OCI）已将其标准化。 Spring。Spring 容器是指应用程序上下文，其中属性和其他应用程序资源被管理和执行。 Servlet。利用 Java Servlet API，Servlet 容器为 web 应用程序提供运行时。如 Tomcat 服务器的 Catalina 组件，就是 Servlet 容器的一个示例。 虚拟化和容器并不是相互排斥的。实际上，您可以在云中同时使用它们：在虚拟机组成的基础架构中运行容器。IaaS 模型（基础架构即服务）提供了一个虚拟化层，可以用于引导新的虚拟机。最重要的是，您可以直接运行您的容器。 在开发或执行一些早期测试时，应用程序通常由在同一台机器上运行的不同容器组成。但您很快就会发现，需要管理的容器太多，实在太复杂了。尤其是当您为扩展性而开始复制容器时，将容器分布到不同的机器上。那时，您就应该开始依赖 CaaS 模型（容器即服务）提供更高级别的抽象了。它提供计算机集群中部署和管理容器的功能。请注意，在此场景中，仍然有一个虚拟化层。 即使在使用诸如 Heroku 或 Cloud Foundry 之类的 PaaS 平台时，也会涉及容器。您在这些平台上部署应用程序，只需提供 JAR 工件，平台处理 Java 运行时环境、中间件、操作系统和任何需要的依赖项。在幕后，他们用所有这些组件构建了一个容器，并最终运行了您的 JAR。所不同的是，不再由您负责建造一个容器，而是平台本身为您完成了这一任务。一方面，这很方便，开发人员的责任少了。另一方面，您放弃了对运行时和中间件的控制，只能使用供应商固定提供的中间件类型。 在这本书中，您将学习如何使用 Cloud Native Buildpacks 对 Spring 应用程序进行容器化，您将使用 Docker 在本地环境中运行它们。 "},"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.2-Orchestration.html":{"url":"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.2-Orchestration.html","title":"1.6.2 编排","keywords":"","body":"1.6.2 编排 现在您决定使用容器了，真是太好了！您可以依靠容器的可移植性，将它们部署到提供容器运行时的任何基础架构中。实现了可再现性，所以将容器从开发环境转移到暂存环境，再转移到生产时都很方便。您可以快速缩放，因为它们是如此轻量。还为您的应用程序提供了高可用性，所以可以快速地对它们进行更新。您已经完全准备好将它们用于您的下一个云原生系统了，是吗？ 在一台机器上配置和管理容器非常简单。但是当您开始处理数十个或数百个容器，这些容器被缩放并部署在多台机器上，您还需要别的东西。 当我们从虚拟服务器（IaaS 模型）转移到容器集群（CaaS 模型）时，我们还需要更新我们的观念。在 IaaS 中，我们关注单个计算节点，就是个虚拟服务器。在 CaaS 中，底层基础设施是抽象的，我们关注的是节点集群。有了 CaaS 解决方案提供的新视角，部署目标将不再是一台机器，而是一个集群。像 Kubernetes 这样的 CaaS 平台，为云原生环境中我们所关心的这些问题，提供了解决方案：跨集群编排容器。这两种不同的拓扑如图 1.11 所示。 图 1.11 容器的部署目标是一台机器，而对于编排器来说，它是一个集群。 容器编排可帮助您自动化许多不同的任务： 管理集群，必要时启动和关闭机器； 将群集中的容器进行调度并部署，直到满足容器对 CPU 和内存的要求； 动态扩展容器实例，利用运行状况监测实现高可用性和韧性； 为容器建立相互通信的网络，定义路由、服务发现和负载平衡； 向因特网公开服务，建立端口和网络； 根据特定标准向容器分配资源； 配置容器中运行的应用程序； 确保安全并强制执行访问控制策略。 指令编排工具是以声明方式完成的，例如，通过 YAML 文件。按照特定工具定义的格式和语言，您通常描述希望实现的状态：希望在群集中部署 3 个 web 应用程序容器副本、向 Internet 公开其服务。 容器编排器可以使用 Kubernetes、Docker Swarm 或 Apache Mesos。在这本书中，您将学习如何使用 Kubernetes 为 Spring 编排应用容器。 "},"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.3-Serverless.html":{"url":"01-Introduction-to-cloud-native/1.6-Cloud-native-topologies/1.6.3-Serverless.html","title":"1.6.3 无服务器架构","keywords":"","body":"1.6.3 无服务器架构 在从虚拟机移到容器之后，云提供的抽象可以进一步提高：这就是无服务器模式。用这个计算模型，您只需构建应用程序。云服务商负责设置应用程序使用的基础架构和服务，包括服务器、数据库和其他支持服务。 这个名字有一定误导性：肯定有服务器，只不过不是您在管理它或在其上部署应用程序。 像 AWS Lambda 和 Azure Functions 这样的 FaaS 平台就是无服务器模式的例子。在使用这些平台时，您只需要提供业务逻辑函数。平台将设置运行该函数所需的整个基础设施。函数是按使用次数计算成本的。 如果您正在为事件驱动应用程序使用函数，则它们将仅在发生事件时运行。事件可以是外部的，也可以由另一个函数生成。例如，当有消息添加到队列中时，函数可能被触发，然后执行函数，最后退出执行。当无需处理时，平台会关闭所有相关资源。所以您可以只为实际使用付费。而在其他云拓扑，如 CaaS 或 PaaS，始终有一台服务器在全天候运行。与传统的系统相比，您可以利用动态伸缩性来减少资源数量，只在特定时间提供服务。无服务器模型仅在必要时才提供资源，如果没有要进行处理的，一切都将关闭。 无服务器模式不仅包括 FaaS，还包括其他技术。例如 Knative 是一种在 Kubernetes 之上构建无服务器平台的工具，可以将应用程序作为容器和函数运行。 除了成本优化之外，无服务器技术还将一些额外的责任从应用转到平台。这可能是一个优势，因为它允许开发人员集中精力，只需关心业务逻辑。您也要认识到，这种情况下必须处理好供应商锁定的问题。每个 FaaS，以及通常的无服务器平台，都有自己的功能和特性 API。一旦开始为特定平台编写函数，就无法轻松地将其移植另一个平台。使用 FaaS 比使用任何其他方法，都更能体现为便利而放弃责任和控制。 "},"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/Introduction.html":{"url":"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/Introduction.html","title":"1.7 云原生应用架构","keywords":"","body":"1.7 云原生应用架构 我们已经到了定义云原并介绍在本书中所依赖的主要技术的最后一步。在上一节中，您已经熟悉了云原生拓扑，特别是容器，将成为我们的计算单元。现在，让我们看看里面有什么，并探索云原生应用有关的架构和设计的高级原则。图 1.12 显示了本节涵盖的主要概念。 图 1.12 云原生架构元素。 "},"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/1.7.1-From-multi-tiered-to-microservice-architectures-and-beyond.html":{"url":"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/1.7.1-From-multi-tiered-to-microservice-architectures-and-beyond.html","title":"1.7.1 从分层到微服务到更高级别","keywords":"","body":"1.7.1 从分层到微服务到更高级别 IT 基础设施始终影响着软件的架构设计和运行方式。起初，我们在大型机上部署单个组件组成的单体应用程序。当互联网和个人电脑变得流行时，我们开始根据 客户端/服务器模式 设计应用程序。这是一个分层的体系结构。这种模式被广泛用于桌面和 web 应用程序，代码分解为表示层、业务层和数据层。 随着应用程序复杂性的增加和对敏捷性的需求，人们开始探索进一步对代码进行分解的方法。一种新的架构风格进入历史舞台：微服务。近几年来，这种架构风格越来越流行，许多公司决定根据这种新风格重构他们的应用程序。微服务与单体应用程序的异同如图 1.13 所示。 图 1.13 单体式与微服务。单体结构是多层的。微服务是由可以独立部署的不同组件组成。 主要区别在于应用程序的分解方式。单体应用程序分为 3 层。相反，基于微服务的应用程序与多个组件关联，每个组件只实现一项功能。还有很多模式被提出，可将单体应用分解为微服务，以处理多个组件而不是一个组件的复杂性。 这本书不是关于微服务的。因此，我不会进行更多详述。如果您是对这个话题感兴趣，Manning 出版社有几本关于微服务的书。比如 Chris Richardson 的 “Microservice Patterns”，还有 John Carnell 和 Illary Huaylupo Sanchez 合著的 “Spring Microservices”。如果您不熟悉微服务，不用担心，阅读本书并不要求您必须掌握这这方面的知识。 在经历了多年成功和失败的迁移之后，在开发人员社区，展开了对这种流行的架构风格的激烈讨论。一些开发者建议切换到 微服务以减少组件的数量，从而降低管理它们的复杂性。其他人则提出了 城堡 （citadel） 架构风格，由一个中心的单体，以及环绕的微服务组成。尽管如此，其他人仍在鼓吹以模块化单体的形式回归单体应用。 最后，我认为重要的是选择一个能够支撑我们的业务，为客户提供价值的架构。这也我们开发应用程序的初衷。 每种架构风格都有其用武之地。世上没有银弹或适用一切的解决方案。大多数与微服务相关的负面体验都是由其他问题导致的，例如错误的代码模块化。单体应用与微服务之间不应水火不容。 在本书中，我有兴趣向您展示如何使用 Spring 构建云原生应用程序，并将其作为 Docker 容器部署到 Kubernetes。云原生应用程序是分布式的，就像微服务一样。您将发现通常讨论的微服务主题，实际上属于分布式系统，例如：路由和服务发现。云原生应用程序是松散耦合的，这是微服务的一个特性。 即使存在很多类似的地方，理解云原生应用程序与微服务不完全一样，也是至关重要的。您可以使用微服务风格来实现云原生应用。事实上，许多开发人员都是这样做的。但这不是一个硬性要求。在这本书中，我将使用可能称之为 基于服务 的架构。也许这不是一个吸引人的名字，但这对我们来说已经足够了。我们开发服务，它们可以是任意大小，并且它们可以根据不同的原则进行逻辑封装。以后您想要开发什么样的服务都行，只要根据组织和业务需求来设计。 "},"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/1.7.2-Service-based-architecture-for-cloud-native-applications.html":{"url":"01-Introduction-to-cloud-native/1.7-Architectures-for-cloud-native-applications/1.7.2-Service-based-architecture-for-cloud-native-applications.html","title":"1.7.2 基于服务的云原生应用体系结构","keywords":"","body":"1.7.2 基于服务的云原生应用体系结构 在本书中，您将依据 基于服务 的体系结构来设计开发云原生应用。 您的主要工作内容，是开发一个可以用不同方式与其他服务交互的服务。利用 Cornelia Davis 提出的区别，我们可以确定这种架构中的两个重要元素：服务和交互。 服务（Service）：向另一个组件提供服务的组件。 交互（Interaction）：完成系统要求的，服务之间的通信。 服务是非常通用的组件，它们可能是任何东西。我们可以对它们进行分类，考虑它们是否存储任何类型的状态，可区分应用程序服务（无状态）和数据服务（有状态）。图 1.14 显示了这种云原生体系结构的要素。 图 1.14 云原生应用程序的基于服务的体系结构。主要元素是服务（应用程序或数据）以不同方式相互作用。 应用程序服务 应用程序服务是无状态的，负责实现任何类型的逻辑。他们不必遵守微服务相关的规则，只要它们暴露出云原生应用的属性就行。 最重要的是，在设计每个服务时都要考虑到松耦合和高内聚。服务应尽可能独立。分布式系统是复杂的，所以您应该在设计阶段格外小心。服务数量的增加将导致问题数量的增加。 您可能会独自开发和维护系统中的大多数应用程序服务，但您也可以使用云服务商提供的一些服务，如身份验证或支付服务。 数据服务 数据服务是有状态的，负责存储任何类型的状态。状态（state） 就是一切应该保留的信息，比如在关闭服务并启动新实例时。 它们可以是关系数据库（如 PostgreSQL）、键/值存储（如 Redis）或消息代理（如 RabbitMQ）。您可以自己管理这些服务。因为云原生应用要使用存储来保存状态，这会比您的想象要更具挑战，当然您也会因此而将获得更多控制自己数据的便利。另一种选择是使用云服务商的数据服务，服务商将负责管理与存储、恢复、扩展和性能。在这种情况下，还可以利用专门为云端处理大量数据而构建的服务（如 Amazon DynamoDB 或 Google BigQuery）。 云原生数据服务是一个迷人的主题，但在本书中，我们将主要讨论应用程序。与数据相关的问题，如集群、复制、一致性或分布式事务不会在书中详述。我很想介绍这些，但它们值得用专门的一本书去介绍。 交互 云原生服务相互通信以满足系统的需求。通信方式将影响系统的整体特性。例如：选择 请求/响应 模式（同步 HTTP 调用）而不是基于事件的方法（通过 RabbitMQ 传输的消息）将导致不同级别的恢复能力。在本书中，您将使用各种不同类型的通讯方式，会了解不同通讯方式之间的差异，以及掌握在何时选择何种方式。 "},"01-Introduction-to-cloud-native/Summary.html":{"url":"01-Introduction-to-cloud-native/Summary.html","title":"1.8 总结","keywords":"","body":"1.8 总结 云是一种 IT 基础设施，以商品的形式提供计算、存储和网络资源。用户只为实际使用的资源付费。 云原生应用程序是专为云端运行的应用而设计的高度分布式系统。 云服务商以不同的抽象级别提供服务：基础设施即服务（IaaS）、容器即服务（CaaS）、平台即服务（PaaS）、功能即服务（FaaS）或软件即服务（SaaS）。 云原生应用程序具有水平可扩展性、松散耦合性和高度内聚性，具有故障恢复能力、可管理性和可观察性。 云原生开发由自动化、持续交付和 DevOps 支持。云原生是一种文化，支持不同角色之间的协作，以共同交付业务价值。 现代企业采用云原生技术开发快速交付的软件，可根据需求动态缩放，且始终可用，在优化成本的同时具有故障恢复能力。 容器可以用作计算单元来设计云原生系统。他们比虚拟机更轻量，并提供可移植性、不变性和灵活性。如：Docker。 专用平台提供管理容器的服务，而无需直接处理底层。它们提供容器编排、集群管理、网络服务和调度。如：Kubernetes。 无服务器模式是一种云服务商管理服务器和后端函数的模式，而开发人员只需关注业务逻辑。后端函数在每次使用时计费，以实现成本优化。如：Google Functions。 微服务架构可以用于开发云原生应用程序，但并不是必须的。云原生与微服务不完全相同。 要设计云原生应用程序，您可以使用 基于服务 的架构，其要素是：服务和交互。服务可以进一步分为：应用程序服务（无状态）和数据服务（有状态）。 "}}